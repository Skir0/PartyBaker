// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelGift = `-- name: CancelGift :execresult
update Gifts
set status = 'cancelled'
where contract_address = $1
`

func (q *Queries) CancelGift(ctx context.Context, contractAddress pgtype.Text) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cancelGift, contractAddress)
}

const changeAdmin = `-- name: ChangeAdmin :exec
update Gifts
set admin_id = (select id
                from Users
                where wallet_address = $1
                limit 1)
where contract_address = $2
`

type ChangeAdminParams struct {
	WalletAddress   pgtype.Text
	ContractAddress pgtype.Text
}

func (q *Queries) ChangeAdmin(ctx context.Context, arg ChangeAdminParams) error {
	_, err := q.db.Exec(ctx, changeAdmin, arg.WalletAddress, arg.ContractAddress)
	return err
}

const changeTargetAmount = `-- name: ChangeTargetAmount :exec
update Gifts
set target_amount = $1
where contract_address = $2
`

type ChangeTargetAmountParams struct {
	TargetAmount    pgtype.Int8
	ContractAddress pgtype.Text
}

func (q *Queries) ChangeTargetAmount(ctx context.Context, arg ChangeTargetAmountParams) error {
	_, err := q.db.Exec(ctx, changeTargetAmount, arg.TargetAmount, arg.ContractAddress)
	return err
}

const createEvent = `-- name: CreateEvent :one
insert into Events (name, date, deadline, admin_id)
values ($1, $2, $3, $4)
returning id, name, date, deadline, admin_id
`

type CreateEventParams struct {
	Name     pgtype.Text
	Date     pgtype.Timestamptz
	Deadline pgtype.Timestamptz
	AdminID  int32
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Name,
		arg.Date,
		arg.Deadline,
		arg.AdminID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.Deadline,
		&i.AdminID,
	)
	return i, err
}

const createGift = `-- name: CreateGift :one
insert into Gifts (name, link, target_amount, collected_amount,
                   contract_address, jetton_address,
                   event_id, recipient_id, admin_id)
values ($1, $2, $3, $4, $5,
        $6, $7, $8, $9)
returning id, name, link, target_amount, status, contract_address, jetton_address, event_id, recipient_id, admin_id, collected_amount
`

type CreateGiftParams struct {
	Name            pgtype.Text
	Link            pgtype.Text
	TargetAmount    pgtype.Int8
	CollectedAmount pgtype.Int8
	ContractAddress pgtype.Text
	JettonAddress   pgtype.Text
	EventID         int32
	RecipientID     int32
	AdminID         int32
}

func (q *Queries) CreateGift(ctx context.Context, arg CreateGiftParams) (Gift, error) {
	row := q.db.QueryRow(ctx, createGift,
		arg.Name,
		arg.Link,
		arg.TargetAmount,
		arg.CollectedAmount,
		arg.ContractAddress,
		arg.JettonAddress,
		arg.EventID,
		arg.RecipientID,
		arg.AdminID,
	)
	var i Gift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.TargetAmount,
		&i.Status,
		&i.ContractAddress,
		&i.JettonAddress,
		&i.EventID,
		&i.RecipientID,
		&i.AdminID,
		&i.CollectedAmount,
	)
	return i, err
}

const createParticipant = `-- name: CreateParticipant :one
insert into Participants (role, user_id, event_id)
values ($1, $2, $3)
returning id, role, user_id, event_id
`

type CreateParticipantParams struct {
	Role    pgtype.Text
	UserID  int32
	EventID int32
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, createParticipant, arg.Role, arg.UserID, arg.EventID)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.UserID,
		&i.EventID,
	)
	return i, err
}

const createParticipantGift = `-- name: CreateParticipantGift :one
insert into Participant_Gift (is_paid, amount,
                              transaction_hash, participant_id, gift_id)
values ($1, $2, $3, $4, $5)
on conflict (transaction_hash) do nothing
returning is_paid, amount, transaction_hash, participant_id, gift_id
`

type CreateParticipantGiftParams struct {
	IsPaid          pgtype.Bool
	Amount          pgtype.Int8
	TransactionHash pgtype.Text
	ParticipantID   int32
	GiftID          int32
}

func (q *Queries) CreateParticipantGift(ctx context.Context, arg CreateParticipantGiftParams) (ParticipantGift, error) {
	row := q.db.QueryRow(ctx, createParticipantGift,
		arg.IsPaid,
		arg.Amount,
		arg.TransactionHash,
		arg.ParticipantID,
		arg.GiftID,
	)
	var i ParticipantGift
	err := row.Scan(
		&i.IsPaid,
		&i.Amount,
		&i.TransactionHash,
		&i.ParticipantID,
		&i.GiftID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into Users (first_name, last_name, username, lang_code, wallet_address)
values ($1, $2, $3, $4, $5)
returning id, first_name, last_name, username, created_at, lang_code, wallet_address
`

type CreateUserParams struct {
	FirstName     pgtype.Text
	LastName      pgtype.Text
	Username      pgtype.Text
	LangCode      pgtype.Text
	WalletAddress pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.LangCode,
		arg.WalletAddress,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.CreatedAt,
		&i.LangCode,
		&i.WalletAddress,
	)
	return i, err
}

const decreaseCollectedAmount = `-- name: DecreaseCollectedAmount :exec
update Gifts
set collected_amount = collected_amount - $1
where contract_address = $2
`

type DecreaseCollectedAmountParams struct {
	CollectedAmount pgtype.Int8
	ContractAddress pgtype.Text
}

func (q *Queries) DecreaseCollectedAmount(ctx context.Context, arg DecreaseCollectedAmountParams) error {
	_, err := q.db.Exec(ctx, decreaseCollectedAmount, arg.CollectedAmount, arg.ContractAddress)
	return err
}

const deleteParticipantGift = `-- name: DeleteParticipantGift :exec
delete
from participant_gift
    using participants, users, gifts
where participant_gift.participant_id = participants.id
  and participants.user_id = users.id
  and participant_gift.gift_id = gifts.id
  and gifts.contract_address = $1
  and users.wallet_address = $2
`

type DeleteParticipantGiftParams struct {
	ContractAddress pgtype.Text
	WalletAddress   pgtype.Text
}

func (q *Queries) DeleteParticipantGift(ctx context.Context, arg DeleteParticipantGiftParams) error {
	_, err := q.db.Exec(ctx, deleteParticipantGift, arg.ContractAddress, arg.WalletAddress)
	return err
}

const getAllActiveGiftsAddresses = `-- name: GetAllActiveGiftsAddresses :many
select contract_address
from Gifts
where status = 'active'
`

func (q *Queries) GetAllActiveGiftsAddresses(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getAllActiveGiftsAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var contract_address pgtype.Text
		if err := rows.Scan(&contract_address); err != nil {
			return nil, err
		}
		items = append(items, contract_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllParticipantsOfGift = `-- name: GetAllParticipantsOfGift :many
select id, role, user_id, event_id, is_paid, amount, transaction_hash, participant_id, gift_id
from Participants
         inner join Participant_gift as pg on Participants.id = pg.participant_id
where pg.gift_id = $1
`

type GetAllParticipantsOfGiftRow struct {
	ID              int32
	Role            pgtype.Text
	UserID          int32
	EventID         int32
	IsPaid          pgtype.Bool
	Amount          pgtype.Int8
	TransactionHash pgtype.Text
	ParticipantID   int32
	GiftID          int32
}

func (q *Queries) GetAllParticipantsOfGift(ctx context.Context, giftID int32) ([]GetAllParticipantsOfGiftRow, error) {
	rows, err := q.db.Query(ctx, getAllParticipantsOfGift, giftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllParticipantsOfGiftRow
	for rows.Next() {
		var i GetAllParticipantsOfGiftRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.UserID,
			&i.EventID,
			&i.IsPaid,
			&i.Amount,
			&i.TransactionHash,
			&i.ParticipantID,
			&i.GiftID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGiftByContract = `-- name: GetGiftByContract :one
select id, name, link, target_amount, status, contract_address, jetton_address, event_id, recipient_id, admin_id, collected_amount
from Gifts
where Gifts.contract_address = $1
limit 1
`

func (q *Queries) GetGiftByContract(ctx context.Context, contractAddress pgtype.Text) (Gift, error) {
	row := q.db.QueryRow(ctx, getGiftByContract, contractAddress)
	var i Gift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.TargetAmount,
		&i.Status,
		&i.ContractAddress,
		&i.JettonAddress,
		&i.EventID,
		&i.RecipientID,
		&i.AdminID,
		&i.CollectedAmount,
	)
	return i, err
}

const increaseCollectedAmount = `-- name: IncreaseCollectedAmount :exec
update Gifts
set collected_amount = collected_amount - $1
where contract_address = $2
`

type IncreaseCollectedAmountParams struct {
	CollectedAmount pgtype.Int8
	ContractAddress pgtype.Text
}

func (q *Queries) IncreaseCollectedAmount(ctx context.Context, arg IncreaseCollectedAmountParams) error {
	_, err := q.db.Exec(ctx, increaseCollectedAmount, arg.CollectedAmount, arg.ContractAddress)
	return err
}

const isActiveGift = `-- name: IsActiveGift :one
select exists(select 1
              from Gifts
              where contract_address = $1
                and status = 'active')
`

func (q *Queries) IsActiveGift(ctx context.Context, contractAddress pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, isActiveGift, contractAddress)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const recordTransfer = `-- name: RecordTransfer :exec
insert into participant_gift (participant_id, gift_id, amount, transaction_hash, is_paid)
values ((select participants.id
         from participants
                  join users on participants.user_id = users.id
         where users.wallet_address = $1
           and participants.event_id = (select event_id
                                        from gifts
                                        where gifts.contract_address = $2)
         limit 1),
        (select id from Gifts where contract_address = $2),
        $3, $4, true)
on conflict (transaction_hash) do nothing
`

type RecordTransferParams struct {
	WalletAddress   pgtype.Text
	ContractAddress pgtype.Text
	Amount          pgtype.Int8
	TransactionHash pgtype.Text
}

func (q *Queries) RecordTransfer(ctx context.Context, arg RecordTransferParams) error {
	_, err := q.db.Exec(ctx, recordTransfer,
		arg.WalletAddress,
		arg.ContractAddress,
		arg.Amount,
		arg.TransactionHash,
	)
	return err
}
