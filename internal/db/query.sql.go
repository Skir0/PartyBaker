// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelGiftByContract = `-- name: CancelGiftByContract :execresult
update Gifts
set status = 'cancelled'
where contract_address = $1
`

func (q *Queries) CancelGiftByContract(ctx context.Context, contractAddress pgtype.Text) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cancelGiftByContract, contractAddress)
}

const changeAdminByContract = `-- name: ChangeAdminByContract :exec
update Gifts
set admin_id = $1
where contract_address = $2
`

type ChangeAdminByContractParams struct {
	AdminID         int32
	ContractAddress pgtype.Text
}

func (q *Queries) ChangeAdminByContract(ctx context.Context, arg ChangeAdminByContractParams) error {
	_, err := q.db.Exec(ctx, changeAdminByContract, arg.AdminID, arg.ContractAddress)
	return err
}

const createEvent = `-- name: CreateEvent :one
insert into Events (name, date, deadline, admin_id)
values ($1, $2, $3, $4)
returning id, name, date, deadline, admin_id
`

type CreateEventParams struct {
	Name     pgtype.Text
	Date     pgtype.Timestamptz
	Deadline pgtype.Timestamptz
	AdminID  int32
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Name,
		arg.Date,
		arg.Deadline,
		arg.AdminID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Date,
		&i.Deadline,
		&i.AdminID,
	)
	return i, err
}

const createGift = `-- name: CreateGift :one
insert into Gifts (name, link, price,
                   contract_address, jetton_address,
                   event_id, recipient_id, admin_id)
values ($1, $2, $3, $4, $5,
        $6, $7, $8)
returning id, name, link, price, status, contract_address, jetton_address, event_id, recipient_id, admin_id
`

type CreateGiftParams struct {
	Name            pgtype.Text
	Link            pgtype.Text
	Price           pgtype.Int8
	ContractAddress pgtype.Text
	JettonAddress   pgtype.Text
	EventID         int32
	RecipientID     int32
	AdminID         int32
}

func (q *Queries) CreateGift(ctx context.Context, arg CreateGiftParams) (Gift, error) {
	row := q.db.QueryRow(ctx, createGift,
		arg.Name,
		arg.Link,
		arg.Price,
		arg.ContractAddress,
		arg.JettonAddress,
		arg.EventID,
		arg.RecipientID,
		arg.AdminID,
	)
	var i Gift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.Price,
		&i.Status,
		&i.ContractAddress,
		&i.JettonAddress,
		&i.EventID,
		&i.RecipientID,
		&i.AdminID,
	)
	return i, err
}

const createParticipant = `-- name: CreateParticipant :one
insert into Participants (role, user_id, event_id)
values ($1, $2, $3)
returning id, role, user_id, event_id
`

type CreateParticipantParams struct {
	Role    pgtype.Text
	UserID  int32
	EventID int32
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, createParticipant, arg.Role, arg.UserID, arg.EventID)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.UserID,
		&i.EventID,
	)
	return i, err
}

const createParticipantGift = `-- name: CreateParticipantGift :one
insert into Participant_Gift (is_paid, amount,
                              transaction_hash, participant_id, gift_id)
values ($1, $2, $3, $4, $5)
on conflict (transaction_hash) do nothing
returning is_paid, amount, transaction_hash, participant_id, gift_id
`

type CreateParticipantGiftParams struct {
	IsPaid          pgtype.Bool
	Amount          pgtype.Int8
	TransactionHash pgtype.Text
	ParticipantID   int32
	GiftID          int32
}

func (q *Queries) CreateParticipantGift(ctx context.Context, arg CreateParticipantGiftParams) (ParticipantGift, error) {
	row := q.db.QueryRow(ctx, createParticipantGift,
		arg.IsPaid,
		arg.Amount,
		arg.TransactionHash,
		arg.ParticipantID,
		arg.GiftID,
	)
	var i ParticipantGift
	err := row.Scan(
		&i.IsPaid,
		&i.Amount,
		&i.TransactionHash,
		&i.ParticipantID,
		&i.GiftID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into Users (first_name, last_name, username, lang_code, wallet_address)
values ($1, $2, $3, $4, $5)
returning id, first_name, last_name, username, created_at, lang_code, wallet_address
`

type CreateUserParams struct {
	FirstName     pgtype.Text
	LastName      pgtype.Text
	Username      pgtype.Text
	LangCode      pgtype.Text
	WalletAddress pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.LangCode,
		arg.WalletAddress,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.CreatedAt,
		&i.LangCode,
		&i.WalletAddress,
	)
	return i, err
}

const getAllActiveGiftsAddresses = `-- name: GetAllActiveGiftsAddresses :many
select contract_address from Gifts
where status = 'active'
`

func (q *Queries) GetAllActiveGiftsAddresses(ctx context.Context) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getAllActiveGiftsAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var contract_address pgtype.Text
		if err := rows.Scan(&contract_address); err != nil {
			return nil, err
		}
		items = append(items, contract_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllParticipantsOfGift = `-- name: GetAllParticipantsOfGift :many
select id, role, user_id, event_id, is_paid, amount, transaction_hash, participant_id, gift_id from Participants
inner join Participant_gift as pg on Participants.id = pg.participant_id
where pg.gift_id = $1
`

type GetAllParticipantsOfGiftRow struct {
	ID              int32
	Role            pgtype.Text
	UserID          int32
	EventID         int32
	IsPaid          pgtype.Bool
	Amount          pgtype.Int8
	TransactionHash pgtype.Text
	ParticipantID   int32
	GiftID          int32
}

func (q *Queries) GetAllParticipantsOfGift(ctx context.Context, giftID int32) ([]GetAllParticipantsOfGiftRow, error) {
	rows, err := q.db.Query(ctx, getAllParticipantsOfGift, giftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllParticipantsOfGiftRow
	for rows.Next() {
		var i GetAllParticipantsOfGiftRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.UserID,
			&i.EventID,
			&i.IsPaid,
			&i.Amount,
			&i.TransactionHash,
			&i.ParticipantID,
			&i.GiftID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGiftByContract = `-- name: GetGiftByContract :one
select id, name, link, price, status, contract_address, jetton_address, event_id, recipient_id, admin_id from Gifts
where Gifts.contract_address = $1
limit 1
`

func (q *Queries) GetGiftByContract(ctx context.Context, contractAddress pgtype.Text) (Gift, error) {
	row := q.db.QueryRow(ctx, getGiftByContract, contractAddress)
	var i Gift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.Price,
		&i.Status,
		&i.ContractAddress,
		&i.JettonAddress,
		&i.EventID,
		&i.RecipientID,
		&i.AdminID,
	)
	return i, err
}

const getUserByWallet = `-- name: GetUserByWallet :one
select id from Users
where wallet_address = $1
limit 1
`

func (q *Queries) GetUserByWallet(ctx context.Context, walletAddress pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getUserByWallet, walletAddress)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const isActiveGiftByContract = `-- name: IsActiveGiftByContract :one
select exists(
    select 1 from Gifts
    where contract_address = $1 and status = 'active'
)
`

func (q *Queries) IsActiveGiftByContract(ctx context.Context, contractAddress pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, isActiveGiftByContract, contractAddress)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
